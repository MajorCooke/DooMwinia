/* Sounds
Darwinian/
	Attack
	Attention
	Aye
	Carry
	Carrying
	DSelect
	DStrain
	Hit
	Retreat
	LaserCock
	LaserReload
	LaserHitDarwinian
	Marching
	YesSir
	Choir
	BurnDeath
	Create
	Death
	Jump
	Damage
	OnFire
	Threaten
	Run
*/
Class Darwinian : DWMonster
{
	const MaxTurn = 25.0;
	int ticker;
	double velForward, oldangle;
	Vector3 oldpos;
	double oldroll;
	Class<Actor> SoulActor;
	Actor spawner;
	Actor closest;	double closestDist;
	Actor bits[3];
	bool reversed;
	StateLabel Next;
	Name Status;
	Default
	{
		DesignatedTeam 1;
		Monster;
		+FLOORHUGGER
		-COUNTKILL
		+FLATSPRITE
		+ROLLSPRITE
		+NOBLOOD
		+DOHARMSPECIES
		+ABSMASKPITCH
		+THRUSPECIES
		+CANTLEAVEFLOORPIC
		Health 200;
		Mass 200;
		Scale 0.5;
		Radius 16;
		Height 32;
		Gravity 0.15;
		Speed 5;
		Species "Darwinian";
		PainSound "Darwinian/Damage";
		DeathSound "Darwinian/Death";
		VisibleAngles -80, 80;
		VisiblePitch -360.0, 360.0;
	}	
	Vector2 NextLocation;
	
	enum cooldowns
	{
		CD_Laser = 0,
		CD_Grenade,
		CD_Rocket,
		CD_AttackNoise,
		CD_SightNoise,
	}
	
	uint cooldown[5];
	int boredTimeLeft;
	double boredAngle, boredTurnAmount;
	//==========================================================================
	//
	// States
	//
	//==========================================================================
	
	States
	{
	Spawn:
		M100 A 0
		{
		}
	IdleReturnWait:
		M100 A 4;
	IdleReturn:
		M100 A 0
		{
			UnsetReverse();
			Status = "Bored";
			Next = null;
		}
	Idle:
	Searching:
		M100 A 0
		{
			SearchForActors("DarwinianRocket");
			SearchForActors("DarwinianGrenade");
			
			if (closest)
			{
				Class<Actor> thing = closest.GetClass();
				
				// Prioritize explosives.
				if (thing == "DarwinianGrenade" || thing == "DarwinianRocket")
				{
					A_ClearTarget();
					A_PlaySound("Darwinian/Run",CHAN_AUTO);
					status = "RUNAWAY";
					Next = "RUNAWAY";
				}
				else if (thing == "Darwinian" || thing == "DarwinianPlayer")
				{
					Status = "Attacking";
					Next = "AttackNormal";
				}
				else
				{
					A_ClearTarget();
					closest = null;
					closestDist = 0;
				}
			}
			
			return ResolveState(Next);
		}
	Bored:
		M100 A 4
		{
			Next = null;
			velForward = speed * 0.2;
			if (boredTimeLeft <= 0)
			{
				boredTimeLeft = random(35, 70);
				boredAngle = frandom(30.0, 120.0);
				boredTurnAmount = frandom(MaxTurn * 0.5, MaxTurn) * randompick(-1,1);
			}
			else
			{
				boredTimeLeft -= 4;
				if (boredAngle > 0)
				{
					angle += boredTurnAmount; 
					boredAngle -= abs(boredTurnAmount);
					A_ChangeVelocity(velForward,flags: CVF_RELATIVE|CVF_REPLACE);
				}
			}			
		}
		Goto Searching;
	RUNAWAY:
		"####" "#" 4
		{
			Next = null;
			if (!closest || !closest.TID || Distance2D(closest) > closestDist)
			{
				A_ClearTarget();
				closest = null;
				Next = "IdleReturn";
			}
			SetReverse();
			A_Face (closest, MaxTurn, 270, random(10,15) * randompick(-1,1));
			AngleSlope(angle);
			A_ChangeVelocity(-speed,0,0,CVF_RELATIVE|CVF_REPLACE);
			return ResolveState(Next);
		}
		Wait;
	AttackNormal:
		"####" "#" 4
		{
			if (!target)	
			{
				target = closest;
				closest = null;
			}
			Next = null;
			A_Chase(null,null,CHF_DONTMOVE|CHF_DONTTURN|CHF_NODIRECTIONTURN|CHF_NORANDOMTURN|CHF_NOPOSTATTACKTURN);
			if (!target || !target.bSHOOTABLE || !target.TID || target.DesignatedTeam == DesignatedTeam || 
				Distance2D(target) > closestDist)
			{
				UnsetReverse();
				target = closest = null;
				A_ClearTarget();
				return ResolveState("IdleReturnWait");
			}
			
			if (!cooldown[CD_SightNoise])
			{
				cooldown[CD_SightNoise] = 35*random(10, 30);
				cooldown[CD_AttackNoise] = random(35, 140);
				A_PlaySound("Darwinian/Threaten",CHAN_AUTO);
			}
			
			if (!cooldown[CD_AttackNoise])
			{
				cooldown[CD_AttackNoise] = random(35, 140);
				A_PlaySound("Darwinian/Attack",CHAN_AUTO);
			}
			
			if (abs(velForward) != speed)	velForward = speed;
			
			if (Distance2D(target) > closestDist * 0.75)
			{
				UnsetReverse();
			}
			else
			{
				SetReverse();
			}
			A_Face (target, MaxTurn, 270, random(10,15) * randompick(-1,1));
			AngleSlope(angle);
			
			if (random(1,50) == 1 && !cooldown[CD_Grenade])
			{
				A_SpawnProjectile("DarwinianMuzzleFlash",16,0,0,CMF_OFFSETPITCH);
				A_SpawnProjectile("DarwinianGrenade",16,0,0,CMF_OFFSETPITCH,-30);
			}
			if (random(1,5) == 1 && !cooldown[CD_Laser])
			{
				cooldown[CD_Laser] = 35 * random(1, 2);
				double ran[2];
				ran[0] = frandom(-3.0, 3.0);
				ran[1] = frandom(-3.0, 3.0);
				A_SpawnProjectile("DarwinianMuzzleFlash",16,0,ran[0],CMF_OFFSETPITCH,ran[1]);
				A_SpawnProjectile("DarwinianLaser",16,0,ran[0],CMF_OFFSETPITCH,ran[1]);
			}
			A_ChangeVelocity(velForward,0,0,CVF_RELATIVE|CVF_REPLACE);
			return ResolveState("IdleReturnWait");
		}
		Wait;
	Flying:
		M100 A 1
		{
			if (A_CheckFloor("Null"))
			{
				bFLOORHUGGER = bNOGRAVITY = bCANTLEAVEFLOORPIC = true;
				return ResolveState("IdleReturn");
			}
			return ResolveState(null);
		}
		Loop;
	Operate:
		M100 A 0 
		{
			Status = "Operate";
			AngleSlope(angle);
			oldroll = roll; 
		}
		M100 A 1
		{
			OperateTilt ((level.time * 2.5) % 360.0);
		}
		Wait;
	Death:
		TNT1 A 70 DarwinianDie();
		Stop;
	}
}

extend class Darwinian
{
	//==========================================================================
	//==========================================================================
	//==========================================================================
	// Overrides
	//==========================================================================
	//==========================================================================
	//==========================================================================
	
	//==========================================================================
	// DamageMobj
	//==========================================================================
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0)
	{
		if (health < 1)	return 0;
		bFLOORHUGGER = bNOGRAVITY = bCANTLEAVEFLOORPIC = false;
		int dmg = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		if (dmg > 0 && health > 0)
		{
			A_Pain();
			A_ChangeVelocity(0,0,dmg / 4.0);
			SetStateLabel("Flying");
		}
		else if (dmg < 1)
		{
			bFLOORHUGGER = bNOGRAVITY = bCANTLEAVEFLOORPIC = true;
		}
		return dmg;
	}
	
	//==========================================================================
	// PostBeginPlay
	//==========================================================================
	
	override void PostBeginPlay()
	{
		if (!tid)	
		{
			ChangeTID (TID_Darwinian);
		}
		angle = random(0,359);
		SoulActor = "DigitalSoul";
		Scale.X = 0.5 + frandom(-0.05, 0.05);
		Scale.Y = 0.5 + frandom(-0.05, 0.05);
		bits[0] = Spawn("DarwinianSide",pos);
		bits[1] = Spawn("DarwinianSide",pos);
		if (bits[1]) bits[1].A_SetVisibleRotation(180 - 11.25, 180 + 11.25, 0, 0, VRF_NOPITCH);
		//bits[2] = Spawn("DarwinianBack",pos);
		if (bits[2]) bits[2].A_SetVisibleRotation(90 + 11.25, 270 - 11.25, 0, 0, VRF_NOPITCH);
		for (int i = 0; i < bits.Size(); i++)
		{
			if (bits[i])
			{
				bits[i].Scale = Scale;
				if (bits[i].GetClass() == "DarwinianSide")	bits[i].Scale.X = Scale.X / 4.0;
				bits[i].Translation = Translation;
			}
		}
		Super.PostBeginPlay();
	}

	//==========================================================================
	// Tick
	//==========================================================================
	
	override void Tick()
	{
		if (health < 1)
			return Super.Tick();	
		
		for (int g = 0; g < cooldown.Size(); g++)
		{
			if (cooldown[g] > 0)
				cooldown[g]--;
		}
		
		if (!bFLOORHUGGER)
		{
			for (int i = 0; i < bits.Size(); i++)
			{
				if (bits[i])
				{
					bits[i].SetOrigin(pos,false);
					bits[i].vel = vel;
				}
			}
		}
		else
		{
			ticker = (ticker + 1) % 35;
			if (!(ticker % 17))
			{
				SearchForActors();
			}
			if (!(ticker % 5) && (oldpos != pos || oldangle != angle))
			{
				bINTERPOLATEANGLES = false;
				oldangle = angle;
				oldpos = pos;
				AngleSlope(angle);
				
				for (int i = 0; i < bits.Size(); i++)
				{
					if (bits[i])
					{
						bits[i].SetOrigin(pos,false);
						bits[i].vel = vel;
					}
				}
				if (bits[0] && bits[1])
				{
					bits[0].angle = bits[1].angle = angle + 90;
					bits[0].pitch = bits[1].pitch = roll - 90;
					bits[0].roll = bits[1].roll = -pitch - 90;
				}
				if (bits[2])
				{
					bits[2].angle = angle;
					bits[2].pitch = pitch;
					bits[2].roll = roll;
				}
			}
		}
		Super.Tick();
	}

	//==========================================================================
	// OnDestroy
	//==========================================================================
	override void OnDestroy()
	{
		for (int i = 0; i < bits.Size(); i++)
		{
			if (bits[i])	bits[i].Destroy();
		}
		Super.OnDestroy();
	}
	
	//==========================================================================
	// 
	//==========================================================================
	
	override void AngleSlope (double dang)
	{
		bINTERPOLATEANGLES = false;
		Super.AngleSlope(dang);
		bINTERPOLATEANGLES = true;
	}
	
	//==========================================================================
	//==========================================================================
	//==========================================================================
	// Functions
	//==========================================================================
	//==========================================================================
	//==========================================================================
	
	void DarwinianDie()
	{
		bNOINTERACTION = bTHRUACTORS = true;
		ChangeTID(0);
		double DSpeed = 0;
		if (vel.x + vel.y + vel.z != 0.0)
		{	
			A_FaceMovementDirection();
			DSpeed = vel.Length() * 2;
		}
		A_Stop();
		A_Scream();
		A_Fall();
		
		if (!Soulless)
		{
			if (target && target.GetClass() == "SoulDestroyer")
				SoulActor = "DarwinianGhost";
			A_SpawnItemEx(SoulActor,0,0,height/2.0,cos(pitch) * DSpeed * 0.25, 0, -sin(pitch) * DSpeed * 0.25, 0, 
				SXF_NOCHECKPOSITION|SXF_TRANSFERTRANSLATION);
		}
			
		int rng = random(2,5);
		for (int i = 0; i < rng; i++)
		{
			double np = pitch + frandom(-20.0, 20.0);
			A_SpawnItemEx("DarwinianLimb",0,frandom(-4.0, 4.0),frandom(2.0, 5.5),
				cos(np) * DSpeed,0,-sin(np) * DSpeed,frandom(-20.0,20.0),SXF_NOCHECKPOSITION|SXF_TRANSFERTRANSLATION);
		}
		
		for (int i = 0; i < bits.Size(); i++)
		{
			if (bits[i])	bits[i].Destroy();
		}
	}
	
	//==========================================================================
	//
	// (Un)SetReverse
	//
	// This is my 'solution' to running away from something -- the Darwinian
	// does a full 180 and it's completely unnoticeable, while facing the 
	// threat, allowing it to appear as if they're actually facing away from it.
	//
	//==========================================================================
	
	void SetReverse()
	{
		if (health < 1)	return;
		if (!reversed)
		{
			angle += 180;
			AngleSlope(angle);
			reversed = true;
			velForward = -abs(velForward);
		}
	}
	
	void UnsetReverse()
	{
		if (health < 1)	return;
		if (reversed)
		{
			angle += 180;
			AngleSlope(angle);
			reversed = false;
			velForward = abs(velForward);
		}
	}
	
	//==========================================================================
	// Operating
	//==========================================================================
	
	void OperateTilt (double amt)
	{
		if (health < 1)	return;
		//roll = oldroll + sin(amt) * 3;
		roll += sin(amt) * 30;
	}
	
	//==========================================================================
	// Actor Search
	//==========================================================================
	
	void SearchForActors(Class<Actor> Specific = null)
	{
		if (health < 1)	return;
		// Search for high priority threats first.
		
		static const int ActorID[] =
		{
			TID_SoulDestroyer,
			TID_Grenade,
			TID_Rocket,
			TID_Darwinian,
			TID_Darwinian
		};
		static const Class<Actor> ActorList[] =
		{
			"SoulDestroyer",
			"DarwinianGrenade",
			"DarwinianRocket",
			"DarwinianPlayer",
			"Darwinian"
		};
		
		static const int ActorDistance[] =
		{
			512,
			256,
			256,
			384,
			384
		};
		
		int size = ActorList.Size();
		for (int g = 0; g < size; g++)
		{
			if (Specific && ActorList[g] != Specific)
				continue;
				
			// See ZMisc.txt
			int id = 					ActorID[g];
			double dist = 				ActorDistance[g];
			Class<Actor> cname = 		ActorList[g];
			
			let it = ActorIterator.Create(id, cname);
			Actor mo;
			while (mo = it.Next())
			{	
				if (!mo.TID || mo == self || mo.DesignatedTeam == DesignatedTeam || mo.bINVISIBLE)
					continue;
					
			//	if (mo.GetClass() != "DarwinianGrenade" && isTeammate(mo))
			//		continue;
				
				if (Distance2D(mo) > dist)
					continue;
			
				if (mo.tid == TID_Darwinian && !(mo is "PlayerPawn") && !(mo is "Darwinian"))
					continue;
			
				//if (!CheckSight(mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
				//	continue;
				
				closest = mo;
				closestDist = dist;
				return;
			}
		}
	}
}