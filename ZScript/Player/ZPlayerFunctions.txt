extend class DarwinianPlayer
{
	bool Damaged;
	//==========================================================================
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0)
	{
		int dmg = damage, realdmg = damage;
		
		damage = Clamp(damage, 0, TELEFRAG_DAMAGE - 1);
		
		if (GameOver) //Kill it and don't respawn.
		{
			// You win NOTHING.
			// YOU LOSE.
			// GOOD DAY SIR.
			flags |= DMG_FORCED|DMG_THRUSTLESS;
			damage = health * 10;
		}
		else
		{
		
			// There's a reason for this. The player must absolutely not die until the game is over.
			flags &= ~DMG_FORCED;
		}
		
		dmg = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		Damaged = (!GameOver && dmg > 0);
		if (health == 1 && !(player.cheats & CF_BUDDHA2))
		{
			// The 'fake' death. In short, the player 'dies' technically, but
			// in reality they just become an invisible version of themselves
			// that cannot attack but can move through things like a ghost.
			// Based on how they were killed, they will respawn after X amount
			// of seconds.
			
			// Darwinians:		5-10
			// Monsters:		10-20
			// Soul Destroyer:	30+
			// Stupidity:		30+
			
			RespawnTimer = 35 * 5;
			SetDead();
			dead = true;
			
			
			
			Actor src = (source != null) ? source : inflictor;
			
			if (src)
			{
				//	 if (src == self || src.GetClass() == "SoulDestroyer")	RespawnTimer = 35 * 30;
				//else if (src is "Darwinian" || src is "DarwinianPlayer")	RespawnTimer = 35 * 5;
				//else 														RespawnTimer = 35 * 10;
				if (src.GetClass() == "SoulDestroyer")	SoulActor = "DarwinianGhost";
				else									SoulActor = "DigitalSoul";
			}
			
			DarwinianDie();
			
			if (!bNOPAIN)	
			{
				
				A_PlaySound("Darwinian/Hit",CHAN_BODY);
			}
			A_PlaySound("Darwinian/Death",CHAN_VOICE);
			
		}
		else if (health < 1)
		{
			// The REAL death only happens if they lose the game. This means
			// no respawning.
			dead = true;
			if (!bNOPAIN)	
			{
				A_PlaySound("Darwinian/Hit",CHAN_BODY);
			}
			A_PlaySound("Darwinian/Death",CHAN_VOICE);
			SetPlayerProperty(0,true,PROP_TOTALLYFROZEN);
			return dmg;
		}
		else if (dmg > 0)
		{
			if (!bNOPAIN)	
			{
				A_PlaySound("Darwinian/Damage",CHAN_VOICE);
			}
			A_PlaySound("Darwinian/Hit",CHAN_BODY);
		}
		return dmg;
	}
	//==========================================================================
	//==========================================================================
	override void PostBeginPlay()
	{
		Scale.X = 0.5 + frandom(-0.05, 0.05);
		Scale.Y = 0.5 + frandom(-0.05, 0.05);
		
		if (!player || !player.mo || player.mo != self)
			return Super.PostBeginPlay();
			
		if (!tid)
		{
			ChangeTID(TID_Darwinian);
		}
		
		//Entities[HitBox] = Spawn("DarwinianPlayerHitBox", pos);
		//Entities[ChaseCam] = Spawn("ChaseCam", pos);
		Entities[ThirdPerson] = Spawn("DarwinianThirdPerson", pos, NO_REPLACE);
		
		for (int i = 0; i < Entities.Size(); i++)
		{
			if (Entities[i] != null)
			{
				Entities[i].Angle = Angle;
				Entities[i].Translation = Translation;
				Entities[i].master = self;
				Entities[i].Scale = Scale;
			}
		}
		
		let a1 = DWBase(Entities[HitBox]);
		if (a1)	a1.DesignatedTeam = DesignatedTeam;
		
		if (!SpawnAir)
		{
			A_Warp(DefPtr,0,0,0,0,WARPF_NOCHECKPOSITION|WARPF_TOFLOOR);
			bFLOORHUGGER = true;
			SetAlive();
		}
		
		Super.PostBeginPlay();
	}
	//==========================================================================
	//==========================================================================
	override void Tick()
	{
		if (!player || !player.mo || player.mo != self || GameOver || health < 1)
			return Super.Tick();
			
		if (dead)
		{
			if (!GameOver)
			{
				if (RespawnTimer <= 0)
					SetAlive();
				else
					RespawnTimer--;
			}
			return Super.Tick();
		}
		
		if (GetCvar("debughax"))
		{
			int ip = GetPlayerInput(MODINPUT_BUTTONS);
			int iz = GetPlayerInput(MODINPUT_OLDBUTTONS);
			if (ip & BT_USER3 && !(iz & BT_USER3))
			{
				DesignatedTeam = Clamp((DesignatedTeam + 1) % 9, 1, 8);
				A_LogInt(DesignatedTeam);
			}
		}
		
		
		if (player.cheats & (CF_NOCLIP|CF_NOCLIP2))
			bFLOORHUGGER = false;
		else if (!bFLOORHUGGER)
			bFLOORHUGGER = (A_CheckFloor("Spawn") && vel.z == 0);
		
		// ALWAYS make sure players have buddha.
		bBUDDHA = true;
		
		invis = (player.cheats & CF_CHASECAM);
		A_SetRenderStyle(1.0,(player.cheats & CF_CHASECAM) ? STYLE_None : STYLE_Normal);		
				
		
		//----------------------------------------------------------------------
		// Process speed handling.
		//----------------------------------------------------------------------
		if (bFLOORHUGGER)
		{
			let input = GetPlayerInput(MODINPUT_BUTTONS);
			
			bool forward = (input & BT_FORWARD);
			bool backward = (input & BT_BACK);
			bool left = (input & BT_MOVELEFT);
			bool right = (input & BT_MOVERIGHT);
			
			// Save some time by checking to see if they cancel each other out first.
			if ((forward != backward) || (left != right))
			{
				double	baseVel = 		5.0, // The speed to move by.
						pitchMod = 		1.0, // The multiplier based on moving up or down.
						forwardvel = 	0.0, // The end result for going forward or backward.
						sidevel = 		0.0; // The end result for strafing.

				if (Entities[ThirdPerson])
				{
					// Slow down if going up, speed up if going down.
					double tp = Entities[ThirdPerson].pitch + 90;
					pitchMod = (tp < 0.0) ? cos(tp) : 1 + sin(tp);
					pitchMod = Clamp(pitchMod, 0.2, 1.8);
				}
				if (forward)	forwardVel += baseVel;
				if (backward)	forwardVel -= baseVel;
				if (left)		sidevel += baseVel;
				if (right)		sidevel -= baseVel;
				
				if (forward || backward || left || right)
				{
					if (input & BT_SPEED)
					{
						forwardvel /= 2.0;
						sidevel /= 2.0;
					}
					// Sorry guys, no strafe running!
					if (forwardvel != 0.0 && sidevel != 0.0)
					{	forwardvel *= 0.7;	sidevel *= 0.7;	}
					A_ChangeVelocity(forwardvel * pitchMod, sidevel * pitchMod, vel.z, CVF_RELATIVE|CVF_REPLACE);
				}
			}
		}
		for (int i = 0; i < Entities.Size(); i++)
		{
			if (Entities[i] != null)
			{
				Entities[i].vel = vel;
				Entities[i].SetOrigin(pos,false);
			}
		}
		
		Super.Tick();
		bNOGRAVITY = bFLOORHUGGER;
	}
	//==========================================================================
	override bool CanCollideWith(Actor other, bool passive)
	{
		return (other is "DWMonster");
	}
	//==========================================================================
	override void PlayAttacking() { }
	override void PlayAttacking2() { }
	override void PlayRunning() { }
	override void PlayIdle() { }
	//==========================================================================
	
	
	
	
	
	
	
	
	void DarwinianDie()
	{
		
		double DSpeed = 0, oldAngle = angle, oldPitch = pitch;
		if (vel.x + vel.y + vel.z != 0.0)
		{	
			A_FaceMovementDirection();
			DSpeed = vel.Length() * 2;
		}
		A_Stop();
		A_Scream();
		A_Fall();
		
		if (!Soulless)
		{
			// The soul is set up in the DamageMobj override.
			A_SpawnItemEx(SoulActor,0,0,height/2.0,cos(pitch) * DSpeed * 0.25, 0, -sin(pitch) * DSpeed * 0.25, 0, 
				SXF_NOCHECKPOSITION|SXF_TRANSFERTRANSLATION);
		}
			
		int rng = random(2,5);
		for (int i = 0; i < rng; i++)
		{
			double np = pitch + frandom(-20.0, 20.0);
			A_SpawnItemEx("DarwinianLimb",0,frandom(-4.0, 4.0),frandom(2.0, 5.5),
				cos(np) * DSpeed,0,-sin(np) * DSpeed,frandom(-20.0,20.0),SXF_NOCHECKPOSITION|SXF_TRANSFERTRANSLATION);
		}
		
		angle = oldAngle;
		pitch = oldPitch;
	}
	void SetDead()
	{
		dead = true;
		A_GiveInventory("PowerFlight",1);		
		bVULNERABLE = bFLOORHUGGER = bSHOOTABLE = false;
		bTHRUACTORS = bINVISIBLE = bNOCLIP = bNONSHOOTABLE = true;
		Speed = 1;
	}
	
	void SetAlive()
	{
		A_SetInventory("PowerFlight",0);
		A_ResetHealth();
		bSHOOTABLE = bFLOORHUGGER = true;
		bTHRUACTORS = bNONSHOOTABLE = bNOCLIP = bFLY = bNOGRAVITY = bINVISIBLE = false;
		A_Stop();
		SetOrigin(SpawnPoint, false);
		Speed = 0;
		Angle = SpawnAngle;
		dead = false;
	}
}